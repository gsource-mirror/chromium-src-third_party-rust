From 1cce6bc6c4068b86c46f6a8f00cdff624be7e0db Mon Sep 17 00:00:00 2001
From: Manish Goregaokar <manishearth@google.com>
Date: Tue, 4 Nov 2025 20:23:26 +0000
Subject: [PATCH] Updates for ZonedDateTime since / until issue

Uplifted from https://github.com/boa-dev/temporal/pull/619

Change-Id: Ie575788265ff7217533dcdcc216fb1b7a5aa9be4
---
 .../src/builtins/core/duration/normalized.rs  | 55 ++++++++++++++-----
 .../src/builtins/core/plain_date.rs           |  8 +--
 .../src/builtins/core/plain_date_time.rs      |  3 +
 .../src/builtins/core/plain_year_month.rs     |  1 +
 .../src/builtins/core/zoned_date_time.rs      | 35 ++++++++----
 .../builtins/core/zoned_date_time/tests.rs    | 40 ++++++++++++++
 6 files changed, 113 insertions(+), 29 deletions(-)

diff --git a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/duration/normalized.rs b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/duration/normalized.rs
index 19444ac73dbcd..3750f84f9c39c 100644
--- a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/duration/normalized.rs
+++ b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/duration/normalized.rs
@@ -3,6 +3,7 @@
 use core::{cmp, num::NonZeroU128, ops::Add};
 
 use num_traits::AsPrimitive;
+use timezone_provider::epoch_nanoseconds::EpochNanoseconds;
 
 use crate::{
     builtins::core::{time_zone::TimeZone, PlainDate, PlainDateTime},
@@ -370,6 +371,7 @@ impl InternalDurationRecord {
     fn nudge_calendar_unit(
         &self,
         sign: Sign,
+        origin_epoch_ns: EpochNanoseconds,
         dest_epoch_ns: i128,
         dt: &PlainDateTime,
         time_zone: Option<(&TimeZone, &(impl TimeZoneProvider + ?Sized))>, // ???
@@ -570,33 +572,48 @@ impl InternalDurationRecord {
             }
         };
 
-        // 7. Let start be ? CalendarDateAdd(calendar, isoDateTime.[[ISODate]], startDuration, constrain).
-        let start = dt
-            .calendar()
-            .date_add(&dt.iso.date, &start_duration, Overflow::Constrain)?;
+        let start_epoch_ns = if r1 == 0 {
+            origin_epoch_ns
+        } else {
+            // 7. Let start be ? CalendarDateAdd(calendar, isoDateTime.[[ISODate]], startDuration, constrain).
+            let start =
+                dt.calendar()
+                    .date_add(&dt.iso.date, &start_duration, Overflow::Constrain)?;
+            // 9. Let startDateTime be CombineISODateAndTimeRecord(start, isoDateTime.[[Time]]).
+            let start_date_time = IsoDateTime::new_unchecked(start.iso, dt.iso.time);
+            if let Some((time_zone, provider)) = time_zone {
+                time_zone
+                    .get_epoch_nanoseconds_for(
+                        start_date_time,
+                        Disambiguation::Compatible,
+                        provider,
+                    )?
+                    .ns
+            } else {
+                start_date_time.as_nanoseconds()
+            }
+        };
+
         // 8. Let end be ? CalendarDateAdd(calendar, isoDateTime.[[ISODate]], endDuration, constrain).
         let end = dt
             .calendar()
             .date_add(&dt.iso.date, &end_duration, Overflow::Constrain)?;
-        // 9. Let startDateTime be CombineISODateAndTimeRecord(start, isoDateTime.[[Time]]).
-        let start = IsoDateTime::new_unchecked(start.iso, dt.iso.time);
+
         // 10. Let endDateTime be CombineISODateAndTimeRecord(end, isoDateTime.[[Time]]).
         let end = IsoDateTime::new_unchecked(end.iso, dt.iso.time);
 
         // 12. Else,
-        let (start_epoch_ns, end_epoch_ns) = if let Some((time_zone, provider)) = time_zone {
+        let end_epoch_ns = if let Some((time_zone, provider)) = time_zone {
             // a. Let startEpochNs be ? GetEpochNanosecondsFor(timeZone, startDateTime, compatible).
             // b. Let endEpochNs be ? GetEpochNanosecondsFor(timeZone, endDateTime, compatible).
-            let start_epoch_ns =
-                time_zone.get_epoch_nanoseconds_for(start, Disambiguation::Compatible, provider)?;
-            let end_epoch_ns =
-                time_zone.get_epoch_nanoseconds_for(end, Disambiguation::Compatible, provider)?;
-            (start_epoch_ns.ns, end_epoch_ns.ns)
+            time_zone
+                .get_epoch_nanoseconds_for(end, Disambiguation::Compatible, provider)?
+                .ns
         // 11. If timeZoneRec is unset, then
         } else {
             // a. Let startEpochNs be GetUTCEpochNanoseconds(start.[[Year]], start.[[Month]], start.[[Day]], start.[[Hour]], start.[[Minute]], start.[[Second]], start.[[Millisecond]], start.[[Microsecond]], start.[[Nanosecond]]).
             // b. Let endEpochNs be GetUTCEpochNanoseconds(end.[[Year]], end.[[Month]], end.[[Day]], end.[[Hour]], end.[[Minute]], end.[[Second]], end.[[Millisecond]], end.[[Microsecond]], end.[[Nanosecond]]).
-            (start.as_nanoseconds(), end.as_nanoseconds())
+            end.as_nanoseconds()
         };
 
         // TODO: look into handling asserts
@@ -954,6 +971,7 @@ impl InternalDurationRecord {
     #[inline]
     pub(crate) fn round_relative_duration(
         &self,
+        origin_epoch_ns: EpochNanoseconds,
         dest_epoch_ns: i128,
         dt: &PlainDateTime,
         time_zone: Option<(&TimeZone, &(impl TimeZoneProvider + ?Sized))>,
@@ -974,7 +992,14 @@ impl InternalDurationRecord {
         let nudge_result = if irregular_length_unit {
             // a. Let record be ? NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, increment, smallestUnit, roundingMode).
             // b. Let nudgeResult be record.[[NudgeResult]].
-            duration.nudge_calendar_unit(sign, dest_epoch_ns, dt, time_zone, options)?
+            duration.nudge_calendar_unit(
+                sign,
+                origin_epoch_ns,
+                dest_epoch_ns,
+                dt,
+                time_zone,
+                options,
+            )?
         } else if let Some((time_zone, time_zone_provider)) = time_zone {
             // 6. Else if timeZone is not unset, then
             //      a. Let nudgeResult be ? NudgeToZonedTime(sign, duration, isoDateTime, timeZone, calendar, increment, smallestUnit, roundingMode).
@@ -1012,6 +1037,7 @@ impl InternalDurationRecord {
     // 7.5.38 TotalRelativeDuration ( duration, destEpochNs, isoDateTime, timeZone, calendar, unit )
     pub(crate) fn total_relative_duration(
         &self,
+        origin_epoch_ns: EpochNanoseconds,
         dest_epoch_ns: i128,
         dt: &PlainDateTime,
         time_zone: Option<(&TimeZone, &(impl TimeZoneProvider + ?Sized))>,
@@ -1024,6 +1050,7 @@ impl InternalDurationRecord {
             // b. Let record be ? NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, 1, unit, trunc).
             let record = self.nudge_calendar_unit(
                 sign,
+                origin_epoch_ns,
                 dest_epoch_ns,
                 dt,
                 time_zone,
diff --git a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date.rs b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date.rs
index 8e3b1d82c7807..31ba19eb5ad74 100644
--- a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date.rs
+++ b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date.rs
@@ -279,15 +279,15 @@ impl PlainDate {
             resolved.smallest_unit == Unit::Day && resolved.increment.get() == 1;
         // 12. If roundingGranularityIsNoop is false, then
         if !rounding_granularity_is_noop {
+            let iso_date_time = IsoDateTime::new_unchecked(self.iso, IsoTime::default());
+            let origin_epoch_ns = iso_date_time.as_nanoseconds();
             // a. Let destEpochNs be GetUTCEpochNanoseconds(other.[[ISOYear]], other.[[ISOMonth]], other.[[ISODay]], 0, 0, 0, 0, 0, 0).
             let dest_epoch_ns = other.iso.as_nanoseconds();
             // b. Let dateTime be ISO Date-Time Record { [[Year]]: temporalDate.[[ISOYear]], [[Month]]: temporalDate.[[ISOMonth]], [[Day]]: temporalDate.[[ISODay]], [[Hour]]: 0, [[Minute]]: 0, [[Second]]: 0, [[Millisecond]]: 0, [[Microsecond]]: 0, [[Nanosecond]]: 0 }.
-            let dt = PlainDateTime::new_unchecked(
-                IsoDateTime::new_unchecked(self.iso, IsoTime::default()),
-                self.calendar.clone(),
-            );
+            let dt = PlainDateTime::new_unchecked(iso_date_time, self.calendar.clone());
             // c. Set duration to ? RoundRelativeDuration(duration, destEpochNs, dateTime, calendarRec, unset, settings.[[LargestUnit]], settings.[[RoundingIncrement]], settings.[[SmallestUnit]], settings.[[RoundingMode]]).
             duration = duration.round_relative_duration(
+                origin_epoch_ns,
                 dest_epoch_ns.0,
                 &dt,
                 Option::<(&TimeZone, &NeverProvider)>::None,
diff --git a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date_time.rs b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date_time.rs
index 92f0a8d03304c..cfb316ef87433 100644
--- a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date_time.rs
+++ b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_date_time.rs
@@ -311,6 +311,7 @@ impl PlainDateTime {
         let dest_epoch_ns = other.iso.as_nanoseconds();
         // 6. Return ? RoundRelativeDuration(diff, destEpochNs, isoDateTime1, unset, calendar, largestUnit, roundingIncrement, smallestUnit, roundingMode).
         diff.round_relative_duration(
+            self.iso.as_nanoseconds(),
             dest_epoch_ns.0,
             self,
             Option::<(&TimeZone, &NeverProvider)>::None,
@@ -335,10 +336,12 @@ impl PlainDateTime {
         if unit == Unit::Nanosecond {
             return FiniteF64::try_from(diff.normalized_time_duration().0);
         }
+        let origin_epoch_ns = self.iso.as_nanoseconds();
         // 5. Let destEpochNs be GetUTCEpochNanoseconds(isoDateTime2).
         let dest_epoch_ns = other.iso.as_nanoseconds();
         // 6. Return ? TotalRelativeDuration(diff, destEpochNs, isoDateTime1, unset, calendar, unit).
         diff.total_relative_duration(
+            origin_epoch_ns,
             dest_epoch_ns.0,
             self,
             Option::<(&TimeZone, &NeverProvider)>::None,
diff --git a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_year_month.rs b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_year_month.rs
index 7f2bd41454577..c61d69ed7f00b 100644
--- a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_year_month.rs
+++ b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/plain_year_month.rs
@@ -329,6 +329,7 @@ impl PlainYearMonth {
             let dest_epoch_ns = target_iso_date_time.as_nanoseconds();
             // d. Set duration to ? RoundRelativeDuration(duration, destEpochNs, isoDateTime, unset, calendar, resolved.[[LargestUnit]], resolved.[[RoundingIncrement]], resolved.[[SmallestUnit]], resolved.[[RoundingMode]]).
             duration = duration.round_relative_duration(
+                iso_date_time.as_nanoseconds(),
                 dest_epoch_ns.as_i128(),
                 &PlainDateTime::new_unchecked(iso_date_time, self.calendar.clone()),
                 Option::<(&TimeZone, &NeverProvider)>::None,
diff --git a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time.rs b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time.rs
index a792fe68b59ff..93fe43724278a 100644
--- a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time.rs
+++ b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time.rs
@@ -394,6 +394,7 @@ impl ZonedDateTime {
         let iso = self.get_iso_datetime();
         // 5. Return ? RoundRelativeDuration(difference, ns2, dateTime, timeZone, calendar, largestUnit, roundingIncrement, smallestUnit, roundingMode).
         diff.round_relative_duration(
+            *self.epoch_nanoseconds(),
             other.epoch_nanoseconds().as_i128(),
             &PlainDateTime::new_unchecked(iso, self.calendar().clone()),
             Some((self.time_zone(), provider)),
@@ -425,6 +426,7 @@ impl ZonedDateTime {
         let iso = self.get_iso_datetime();
         // 4. Return ? TotalRelativeDuration(difference, ns2, dateTime, timeZone, calendar, unit).
         diff.total_relative_duration(
+            *self.epoch_nanoseconds(),
             other.epoch_nanoseconds().as_i128(),
             &PlainDateTime::new_unchecked(iso, self.calendar().clone()),
             Some((self.time_zone(), provider)),
@@ -446,29 +448,39 @@ impl ZonedDateTime {
         let start = self.get_iso_datetime();
         // 3. Let endDateTime be GetISODateTimeFor(timeZone, ns2).
         let end = self.time_zone.get_iso_datetime_for(other, provider)?;
-        // 4. If ns2 - ns1 < 0, let sign be -1; else let sign be 1.
+        // 4. If CompareISODate(startDateTime.[[ISODate]], endDateTime.[[ISODate]]) = 0, then
+        if start.date == end.date {
+            // a. Let timeDuration be TimeDurationFromEpochNanosecondsDifference(ns2, ns1).
+            let time_duration = TimeDuration::from_nanosecond_difference(
+                other.epoch_nanoseconds().as_i128(),
+                self.epoch_nanoseconds().as_i128(),
+            )?;
+            // b. Return CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration).
+            return InternalDurationRecord::new(Default::default(), time_duration);
+        }
+        // 5. If ns2 - ns1 < 0, let sign be -1; else let sign be 1.
         let sign = if other.epoch_nanoseconds().as_i128() - self.epoch_nanoseconds().as_i128() < 0 {
             Sign::Negative
         } else {
             Sign::Positive
         };
-        // 5. If sign = 1, let maxDayCorrection be 2; else let maxDayCorrection be 1.
+        // 6. If sign = 1, let maxDayCorrection be 2; else let maxDayCorrection be 1.
         let max_correction = if sign == Sign::Positive { 2 } else { 1 };
-        // 6. Let dayCorrection be 0.
-        // 7. Let timeDuration be DifferenceTime(startDateTime.[[Time]], endDateTime.[[Time]]).
+        // 7. Let dayCorrection be 0.
+        // 8. Let timeDuration be DifferenceTime(startDateTime.[[Time]], endDateTime.[[Time]]).
         let time = start.time.diff(&end.time);
-        // 8. If TimeDurationSign(timeDuration) = -sign, set dayCorrection to dayCorrection + 1.
+        // 9. If TimeDurationSign(timeDuration) = -sign, set dayCorrection to dayCorrection + 1.
         let mut day_correction = if time.sign() as i8 == -(sign as i8) {
             1
         } else {
             0
         };
 
-        // 9. Let success be false.
+        // 10. Let success be false.
         let mut intermediate_dt = IsoDateTime::default();
         let mut time_duration = TimeDuration::default();
         let mut is_success = false;
-        // 10. Repeat, while dayCorrection ≤ maxDayCorrection and success is false,
+        // 11. Repeat, while dayCorrection ≤ maxDayCorrection and success is false,
         while day_correction <= max_correction && !is_success {
             // a. Let intermediateDate be BalanceISODate(endDateTime.[[ISODate]].[[Year]],
             // endDateTime.[[ISODate]].[[Month]], endDateTime.[[ISODate]].[[Day]] - dayCorrection × sign).
@@ -500,14 +512,15 @@ impl ZonedDateTime {
             // g. Set dayCorrection to dayCorrection + 1.
             day_correction += 1;
         }
-        // 11. Assert: success is true.
-        // 12. Let dateLargestUnit be LargerOfTwoUnits(largestUnit, day).
+        // 12. Assert: success is true.
+        // 13. Let dateLargestUnit be LargerOfTwoUnits(largestUnit, day).
         let date_largest = largest_unit.max(Unit::Day);
-        // 13. Let dateDifference be CalendarDateUntil(calendar, startDateTime.[[ISODate]], intermediateDateTime.[[ISODate]], dateLargestUnit).
-        // 14. Return CombineDateAndTimeDuration(dateDifference, timeDuration).
+        // 14. Let dateDifference be CalendarDateUntil(calendar, startDateTime.[[ISODate]], intermediateDateTime.[[ISODate]], dateLargestUnit).
+        // 15. Return CombineDateAndTimeDuration(dateDifference, timeDuration).
         let date_diff =
             self.calendar()
                 .date_until(&start.date, &intermediate_dt.date, date_largest)?;
+
         InternalDurationRecord::new(date_diff.date(), time_duration)
     }
 
diff --git a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time/tests.rs b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time/tests.rs
index ed23cf0c7e47f..7521fa5a58b58 100644
--- a/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time/tests.rs
+++ b/third_party/rust/chromium_crates_io/vendor/temporal_rs-v0_1/src/builtins/core/zoned_date_time/tests.rs
@@ -1146,3 +1146,43 @@ fn test_round_to_start_of_day() {
         assert_eq!(rounded.get_iso_datetime(), known_rounded.get_iso_datetime());
     })
 }
+
+#[test]
+fn test_same_date_reverse_wallclock() {
+    // intl402/Temporal/ZonedDateTime/prototype/since/same-date-reverse-wallclock
+    test_all_providers!(provider: {
+        let later =
+            parse_zdt_with_reject("2025-11-02T01:00:00-08:00[America/Vancouver]", provider).unwrap();
+        let earlier =
+            parse_zdt_with_reject("2025-11-02T01:01:00-07:00[America/Vancouver]", provider).unwrap();
+
+        let diff = DifferenceSettings {
+            largest_unit: Some(Unit::Year),
+            smallest_unit: Some(Unit::Millisecond),
+            ..Default::default()
+        };
+        let duration = later.since_with_provider(&earlier, diff, provider).unwrap();
+        assert_eq!(duration.minutes(), 59);
+
+    })
+}
+
+#[test]
+fn test_relativeto_back_transition() {
+    // intl402/Temporal/Duration/prototype/round/relativeto-dst-back-transition
+    test_all_providers!(provider: {
+        let origin =
+            parse_zdt_with_reject("2025-11-02T01:00:00-08:00[America/Vancouver]", provider).unwrap();
+        let duration = Duration::new(0, 0, 0, 0, 11, 39, 0, 0, 0, 0).unwrap();
+
+        let opts = RoundingOptions {
+            largest_unit: Some(Unit::Day),
+            smallest_unit: Some(Unit::Day),
+            rounding_mode: Some(RoundingMode::HalfExpand),
+            ..Default::default()
+        };
+        let rounded = duration.round_with_provider(opts, Some(origin.into()), provider).unwrap();
+        assert_eq!(rounded.days(), 0);
+
+    })
+}
-- 
2.51.2.1006.ga50a493c49-goog

